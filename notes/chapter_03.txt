Chapter 3 Sending JSON Responses

    - Como enviar respostas JSON da sua API REST.
    - Como codificar objetos Go para JSON usando o pacote encoding/json.
    - Técnicas para customizar a maneira que objetos Go são encodificados como JSON.
    - Como criar um helper para enviar respostas JSON e manter a API consistente.

3.1 Fixed-Format JSON

    Atualizar o healthcheckHandler para que retorne um JSON parecido com este:
        {
            "status": "available",
            "environment": "development",
            "version": "1.0.0"
        }
    
    Vale ressaltar que JSON é apenas um texto, ele poderia ser escrito com w.Write(), io.WriteString() ou qualquer fmt.Fprint.

    Os handlers que respondem com objetos JSON devem incluir o header Content-Type: application/json 
    para que os clientes saibam como interpretar a resposta.

        $ curl -i localhost:4000/v1/healthcheck
            HTTP/1.1 200 OK
            Content-Type: application/json
            Date: Tue, 06 Apr 2021 08:38:12 GMT
            Content-Length: 73

            {"status": "available", "environment": "development", "version": "1.0.0"}

3.2 JSON Encoding
    
    O pacote encoding/json fornece duas possibilidades para codificar objetos para JSON.
        - Invocar a função json.Marshal() 
        - Declarar e utilizar o json.Encoder type
    
    Para enviar JSON através de requisições HTTP, json.Marshal() geralmente é a melhor escolha.
    O json.Marshal() recebe um objeto Go como parâmetro e retorna sua representação JSON em um slice byte[].
    A assinatura desta função se parece com isso:
        func Marshal(v interface{}) ([]byte, error)
    
    O parâmetro v é conhecido como Empty Interface.
    Isso significa que qualquer tipo do Go pode ser passado como o parametro v.

    Atualizar o healthcheckHandler para que ele use json.Marshal() para gerar um JSON a partir de um map.

        $curl localhost:4000/v1/healthcheck -i
            HTTP/1.1 200 OK
            Content-Type: application/json
            Date: Mon, 17 Jun 2024 00:37:06 GMT
            Content-Length: 69

            {"environment":"development","status":"available","version":"1.0.0"}
    
    Creating a writeJSON helper method

        Como a API vai responder JSONs em diferentes lugares faz sentido criar um metodo helper writeJSON().
        Também será preciso um método helper para inseris headers arbitrários nas respostas.
        Com a criação do writeJSON() podemos simplificar o handler healthcheckHandler.

3.3 Encoding Structs

    Vamos criar uma nova struct Movie na pasta internal/data, codifica-la em JSON e retorna-la no método showMovieHandler.
    O objeto json é escrito na resposta usando o helper writeJSON().
    
    É crucial que os campos de Movie sejam exportados, ou seja, declarados com a primeira letra maiuscula.
    Desta forma os campos estarão visiveis a biblioteca encoding/json.

    Changing keys in the JSON object

        É possível customizar os campos codificados no JSON anotando-os com Struct Tags.
        O uso mais comum para isso é alterar a forma com que o nome do campo é apresentado no objeto JSON.

        Vamos anotar os campos da struct Movie para seguir o padrão snake_case.
    
    Hiding struct fields in the JSON object

        Também é possível controlar a visibilidae dos campos individualmente usando as flags omitempty e -(hífen).

        O -(hífen) serve para ocultar um campo sob qualquer ciscunstancia.
        Isso é útil para campos que contêm informações internas do sistema que não são relevantes para seus usuários
        ou informações confidenciais que você não deseja expor.

        O omitempty oculta o campo se e somente se o valor do campo estiver vazio.
        Vazio(empty) significa que:
            - O valor é igual a false, 0 ou "".
            - É um array, slice ou map vazio.
            - É um ponteiro nil ou valor de inteface nil.
        
        O campo CreatedAt deve estar oculto em todos os casos.
        Os campos Year, Runtime e Genres devem ser ocultados da resposta se e somente se forem vazios.

        É possível usar omitempty sem alterar o nome do campo.
        
            Basta fazer:
                `json:",omitempty"`
            ao invés de:
                `json:"year,omitempty"`

        Lembrando que também é possível ocultar um campo do JSON declarando-o com inicial em letra minuscula.
        Usar o -(hifen) é uma boa prática e ajuda na leitura do código.

    Additional Information

        The string struct tag directive

            É possível usar a tag 'string' em campos da struct para forçar os dados a serem representados como uma string na saída JSON.

                type Movie struct {
                    ID        int64     `json:"id"`
                    CreatedAt time.Time `json:"-"`
                    Title     string    `json:"title"`
                    Year      int32     `json:"year,omitempty"`
                    Runtime   int32     `json:"runtime,omitempty,string"` // Add the string directive
                    Genres    []string  `json:"genres,omitempty"` 
                    Version   int32     `json:"version"`
                }

Chapter 3.4 Formatting and Enveloping Responses

    Os objetos JSON retornados nas requisições feitas com CURL ficam fora de formatação no terminal.

        $ curl localhost:4000/v1/healthcheck
        {"environment":"development","status":"available","version":"1.0.0"}

        $ curl localhost:4000/v1/movies/123
        {"id":123,"title":"Casablanca","runtime":102,"genres":["drama","romance","war"],"version":1}
    
    É possível melhorar isso usando a função json.MarshalIndent() ao invés da json.Marshal().
    Este método adiciona espaços, novas linhas e formatação no objeto JSON retornado.

    Atualizar o helper writeJSON() para usar json.MarshalIndent().

    Relative performance

        Apesar de melhorar a legibilidade e experiencia do usuário, o método json.MarshalIndent()
        acaba degradando a performance e aumentando o tamanho das respostas devido aos caracteres de formatação.

    Enveloping responses

        Vamos encapsular os dados do filme retornado em um objeto "movie" no json.
        Beneficios de encapsular o objeto:
            - Torna a resposta auto-documentável e facilita a vida de leitores que a receberem fora de contexto.
            - Reduz o risco de erros de processamento no clientside. Ele só processará o bjeto se a chave for "movie".
            - Mitigar erros de segurança em browsers antigos.

        Vamos criar um "envelope" do tipo map[string]interface{} em helpers.go.
        Alterar o tipo do parametro data do writeJSON() de helpers.go para "envelope".
        Atualizar showMovieHandler para criar uma instância de "envelope" e fornece-la na chamada a writeJSON().
        O mesmo deve ser feito em healthcheckHandler.
